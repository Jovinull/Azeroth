- No futuro, se Entity for base para NPCs e inimigos, mover update() e draw() para Entity e aplicar polimorfismo em GamePanel será um bom passo.
- Substituir os try catch, throw e PrintStackTrace por sistema de logs (ex: SLF4J) assim que o projeto escalar.
-  Refatorar getTileImage() para mapear dinamicamente tiles com índice e nome via arquivo .json, .csv ou .properties.
- Validar estrutura do arquivo de mapa (ex: número de colunas por linha) para evitar ArrayIndexOutOfBoundsException.
- Parametrizar o caminho do mapa no config.properties, com chave map.default.path e leitura em Config.java.
- Explicar melhor com comentários o Draw de TileManager (14 minutos da Aula 5)
- Faz sentido em Entity ter o valor padrão e no tiles.json ter o valor de cada um? é redudante?
- Explicar os calculos da aula 6 nos 14 minutos sobre colisão na qual CollisionChecker.
- Evitar uso direto de System.out.println em produção:
- Criar um método de log utilitário ou utilizar Logger, com opção de ativar via config (enableDebugMode).
- Evitar acoplamento com strings literais como "Key" e "Door":
- Criar um enum GameObjectType (ex: KEY, DOOR) e definir isso nas classes dos objetos.
- Substituir gp.obj[i] = null por um método removeObjectAt(int index) para encapsular lógica e evitar erros futuros.
- Evitar uso de valores mágicos e definir constantes com nomes claros para facilitar manutenção e leitura. Casos identificados: solidArea.x = 8, solidArea.y = 16, Config.TILE_SIZE - Config.COLLISION_BOX_OFFSET (offset ainda não definido), e if (i != 999) na checagem de colisão com objeto.
